---
title: "Malware analysis report: Stealc stealer - part 3"
date:  2024-02-01 06:00:00 +0300
header:
  teaser: "/assets/images/14/stealc-3.png"
categories: 
  - threat-hunting
tags:
  - blueteam
  - malware
  - malwareanalysis
---

This is a last part of our analysis report of Stealc, an information stealer promoted by its supposed developer Plymouth on Russian-language underground forums and sold as malware as a service since January 9, 2023.    

![stealc](/assets/images/14/stealc-3.png)      

## Chrome Cookies

the first file hit is the  **Cookies** file and to avoid detection and security configuration Stealc copies the  **Cookies** file to a new file which enables it to do what it can do without caring about file handles that may look wired if a solution is found that a normal executable owns a handle for cookies file.

![stealc](/assets/images/14/1-9vzTrTBAp1ZIypn8Eeh0_g.png)

so copying the DB files to the  **ProgramData** path will be done with all  **files**.

then Stealc will start accessing DB and execute queries, I am going to explain it in detail step by step, keep reading.

**1- it first calls** [**sqlite_open**](https://www.oreilly.com/library/view/using-sqlite/9781449394592/re302.html) **which opens a database file and returns a handle to the Database connection on the ppb argument**
```C
int sqlite3_open(  
  const char *filename,   /* Database filename (UTF-8) */  
  sqlite3 **ppDb          /* OUT: SQLite db handle */  
);
```
![stealc](/assets/images/14/1-ekCmkBxdGf1zBs2I7H6Glw.png)

**2-compile SQL Query using** [Sqlite3_prepare_v2](https://www.sqlite.org/c3ref/prepare.html) **to be used again to extract data from the DB file**
```C
int sqlite3_prepare_v2(  
  sqlite3 *db,            /* Database handle */  
  const char *zSql,       /* SQL statement, UTF-8 encoded */  
  int nByte,              /* Maximum length of zSql in bytes. */  
  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */  
  const char **pzTail     /* OUT: Pointer to unused portion of zSql */  
);
```
![stealc](/assets/images/14/1--cHdaTxsbiF-BTpN86i1Tw.png)
```SQL
SELECT HOST_KEY, is_httponly, path, is_secure,  
(expires_uc/1000000)-11644480800,name, encrypted_value from cookies
```
so let’s break down this query and see the expected output.

-   `HOST_KEY`: The domain of the website that sets the cookie.
-   `is_httponly`: Whether or not the cookie can be accessed by JavaScript.
-   `path`: The path on the website where the cookie is valid.
-   `is_secure`: Whether or not the cookie is only sent over secure connections.
-   `(expires_uc/1000000)-11644480800`: The expiration date of the cookie in Unix time.
-   `name`: The name of the cookie.
-   `encrypted_value`: The encrypted value of the cookie.

and if we take a look at this Sqlite file in any viewer it will ensure our analysis and decryption phase.

![stealc](/assets/images/14/1-5Sf6hhGQvoh9GTSu_edcTQ.png)

3- **Call** [SQLite3_step](http://oreilly.com/library/view/using-sqlite/9781449394592/re325.html) **which is used to execute a prepared statement obtained from** SQLite_perpare_v2 **and advance to the next row of results**
```C
int sqlite3_step( sqlite3_stmt* stmt );
```
so it will call Sqlite3_step Repeatedly until it returns  **100 -> (SQLITE_ROW), indicating**  that another row of output is available.

![stealc](/assets/images/14/1-RqDHCoqQMDdO5VUHNbX00Q.png)

4-**calls** [Sqlite3_column_text](https://www.oreilly.com/library/view/using-sqlite/9781449394592/re244.html) **and this function will contain the output of the query based on the pushed column number in the iCol argument as a UTF-8 string.**
```C
const unsigned char *sqlite3_column_text(  
  
      sqlite3_stmt *stmt,     // handle to the perpared statemtn  
       int iCol               // the index of the columen to be retrived  
);
```
![stealc](/assets/images/14/1-wpOmH6uKROIqDV8yT6Q_rA.png)

after each API call, it will copy the result to a local or global variable then it will compare the result of the  **index (1) => is_http_only and it** returns a boolean value**. It**  indicates  whether the cookie is marked as HttpOnly, HttpOnly cookies are not accessible via JavaScript.

also, it checks the  **is_secure** element which also returns a boolean output, and in the 2 conditions it will append  **“False” if the output is “0”**

![stealc](/assets/images/14/1-RvV0AJZ5RWpSO4mVUsyLiA.png)

Then it collects all these outputs in one buffer using  **StrCatA** which will be sent to C2.

5-**then it starts handling index 6 “encrypted_value” and this is done by first calling** [sqlite3_column_bytes](https://cpp.hotexamples.com/examples/-/-/sqlite3_column_bytes/cpp-sqlite3_column_bytes-function-examples.html) **to get the length of this column and then calling** [sqlite3_column_blob](https://cpp.hotexamples.com/examples/-/-/sqlite3_column_blob/cpp-sqlite3_column_blob-function-examples.html) **to extract the data of the column but this time in byte format cause it may not be formatted as a string.**

then it will pass the 2 outputs to the  **mw_Decrypt_Using_AES()**  function which will use the generated Asymmetric key obtained before from the local state file after decrypting the key using DAPI to decrypt the encrypted value.

![stealc](/assets/images/14/1-XENIiWQGtRdpwyW8sWWhBw.png)

inside the AES decryption routine it will first compare the first 3 bytes of the encrypted bytes against str  **“v10”** and if it does not match it will exit the function.

![stealc](/assets/images/14/1-Dj3fItFEViImsgJXTj0jPw.png)

and “**v10**” here refers to the version used by the website when it saved the cookies so why does it exit if the version is different?

we have two versions of cookies used by Chrome when it handles cookie encryption,v10, and v11

-   v10: Uses static private key “peanuts” salted with “saltysalt”
-   v11: Stores private key in Operating System’s key chain

then it will decrypt this data using the key handle of AES private key using  **BcryptDecrypt**  API

![stealc](/assets/images/14/1-Q4TQqlPZgRDfbKyADPQbzw.png)

after decryption, it will append the decrypted cookie value to the buffer which will be sent to the C2 server, and it will iterate over all the db file to retrieve the encrypted_value column values and decrypt it.

and here is how the data is formatted for every record.

![stealc](/assets/images/14/1-lbSPjec1owIEa_ZSZ0cLIw.png)

and the cookies buffer is  **base64** encoded and sent to the  **C2** server, and as the first data is pushed to  **C2** a packet ID is generated and appended to HTTP headers.

![stealc](/assets/images/14/1-yYUzKLuQBjRsTCLFqk074w.png)

after that, it will close the DataBase handle and delete the dropped file.

![stealc](/assets/images/14/1-85oXAeGbFZvpYvG_QXzICw.png)

## Chrome History

the same as cookies is done with the  **History** file.

1-get handle for  `**_AppData\Local\Google\Chrome\User Data\Default\History_**`

2-copy the file to  **%programdata%**  folder with a random name

3-open handle to the database file.

4-Execute a query to retrieve the first 1000 history record
```sql
SELECT url FROM urls LIMIT 1000
```
5- base64 data and send it to C2 then close database handle and delete the file from  **%programdata%** folder.

## Chrome Login Data

after collecting cookies and history it will get a handle to the  **login_data** file

`**_AppData\Local\Google\Chrome\User Data\Default\Login Data_**`

which contains the username and password for every website the user logged to.

the query in this case is different

![stealc](/assets/images/14/1-dnj1VjLrWzA0Ex0dAEl_Ow.png)
```sql
SELECT origin_url, username_value, password_value FROM logins
```
the  **password_value** is AES Encrypted so it will handle it as same as the cookies file.

![stealc](/assets/images/14/1-50T9U9l6uzl6X2HkoQmqWQ.png)

The Chrome login data is not sent directly after allocating it , because it allocates all logins related to all browsers in the victim machine then it sends them into one buffer but absolutely the data is formatted to identify the browser these data belong to.

## Chrome Web Data: autofill data

This file is so important as login data this file contains information about many settings :

-   autofill data
-   contact info
-   saved credit cards
-   IBANs numbers
-   all payment data

it handles web data via 2 phases, first, it tries to get autofill data and saves it remotely in a txt file, and here is the query used to retrieve auto-fill data.

![stealc](/assets/images/14/1-LRHkldWn-k9TP1YYPaV7sg.png)

SELECT name, value FROM autofill

to test all of this I previously created a record in Chrome to be saved in a web data file and our stealer here succeeded in retrieving this data

> **_fname_**
> 
> **_lname_**
> 
> **_email_**

![stealc](/assets/images/14/1-rJLVoVHQUW_lOz4xFsNw0Q.png)

and then it resolves a string to identify this data cause it is specifically related to Chrome using this string => `**“autofill\Google Chrome_Default.txt”**`

and then send the data to c2, and then it closes the DB handle.

## Chrome Web Data: Credit Card data

after that, it will try to retrieve saved credit cards in Chrome and append this string to be used as an identifier to this data or it will be used to save this data remotely in c2.

`**“cc\Google Chrome_Default.txt”**`

and it executes this query which will be used to retrieve the card name, exp month and year, and card number.
```SQL
SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted FROM credit_cards
```
![stealc](/assets/images/14/1-EBnPizH8_KQiRMzO2eEUAg.png)

and then the card number will be decrypted using the AES key handle and then the data will be sent to C2, it closes the DB handle and removes the dropped file in the  **%programdata% folder**.

## Chrome Extensions (Crypto Wallets):

as we know some extensions handle cryptocurrency operations that act as  **crypto wallets**  and these extensions are targeted by  **Stealc,** so after it steals browser data it will iterate over all extensions that had been downloaded previously to extract its data and send it to TA, How does this happens? that is what I will explain next.

it first gets a pointer to an array of structures, and every structure contains data about a specific extension like name, name length, and ID
```C
struct extension  
{  
  Dword* Name_ptr;  
  Dword Null_bytes;  
  Dword Name_length;  
  Dword* ID_ptr  
}:
```
![stealc](/assets/images/14/1-F6WLEOdxWO3V397L3dpXog.png)

then using FindFirstFile and FindNextFile it iterates over all folders in  **UserData** folder just to get the path of the extension and due to time the required file path is :

`**_%APPDATA%local\Google\Chrome\UserData\Default\local extension settings\<Extension_ID >_**`

and then after getting the path of this file, it will then construct an identifier for this file to be used in c2 communication to identify this data.

I have installed  **MetaMask** Extension to simulate this process and the constructed Identifier contains the browser this extension is installed on and the plugin name and “**local**” or “**Sync**” extension to identify if the extension data is saved locally or being synchronized with a remote server.

`**_plugins\MetaMask\Google Chrome\Default\Local Extension Settings_**`

then it will copy this first file on the extension folder to a program data path as it did before with web data

![stealc](/assets/images/14/1-7qjkTp0nWULufdmexS6GLA.png)

it then reads this file by allocating a buffer using  **localalloc** and then using  **Readfile** with ReadOnly Handle gotten by  **CreateFileA** it fills the buffer with file data.

and here is the file that will be used in the C2 connection as ID for the posted data.

`**_plugins\MetaMask\Google Chrome\Default\Local Extension Settings\000005.ldb_**`

then it will encode the data and the file Identifier using base64 and send it to C2, and it does this for all files in the <**extension_id>** folder, in my case when I installed MetaMask:

![stealc](/assets/images/14/1-bzBqqvk2dqkT_rPKs_NgVQ.png)

and then will iterate over the full array of extensions and try to find its files if it is and send them to the  **TA** server.

## Firefox Credentials:

due to that,  **_Stealc_** handles Opera-based browsers the same as Chrome but the DB files are saved in different destinations, so I will explain the difference between file structure and settings of Chrome and Firefox

it first constructs the path where Firefox saves its data

`**_C:\Users\REM\AppData\Roaming\Mozilla\Firefox\Profiles_**`

and then start downloading 6 DLLs by constructing the URL of each DLL and the local folder to be saved in.

![stealc](/assets/images/14/1-0pAKC9BFsk_-tiiROoKknw.png)

it downloads 6 Dlls to be used to retrieve  **Firefox** Data

-   Freebl3.dll
-   mozglue.dll
-   nss3.dll
-   vcruntime140.dll
-   softokn3.dll
-   msvcp140.dll

![stealc](/assets/images/14/1-R3M1plDraadku-zjyoXugw.png)

then it drops these Dlls in the ProgramData path

![stealc](/assets/images/14/1-lpcTIFh1oYtDVdcJS4Xh1A.png)

then it will start resolving some APIs from Nss3.dll by first getting a handle to this DLL and then trying to get addresses for :

-   NSS_Init
-   NSS_Shutdown
-   PK11_GetInternalKeySlot
-   PK11_FreeSlot
-   PK11_Authenticate
-   PK11SDR_Decrypt

![stealc](/assets/images/14/1-Q0CbfQp7I-RBUV7W2Myjtw.png)

and when it comes to Firefox it will search for 4 files that contain user data and browsing settings

`C:\Users\<Username>\AppData\Roaming\Mozilla\Firefox\Profiles\<ProfileName>\cookies.sqlite_**`

-   This file is responsible for storing information about web cookies

`C:\Users\<Username>\AppData\Roaming\Mozilla\Firefox\Profiles\<ProfileName>\formhistory.sqlite_**`

-   database file used by Mozilla Firefox to store information related to web forms and user input.

`C:\Users\<Username>\AppData\Roaming\Mozilla\Firefox\Profiles\<ProfileName>\places.sqlite_**`

-   database file used by the Mozilla Firefox web browser to store various information related to your browsing history, bookmarks, and other web-related data

`C:\Users\<Username>\AppData\Roaming\Mozilla\Firefox\Profiles\<ProfileName>\logins.json_**`

-   stores all of the saved logins for the Firefox profile. This includes the website URL, username, and password for each saved login

For the  **3 SQLite**  files it handles them the same as Chrome using Sqlite APIs resolved before but with different queries, and also the data is not encrypted as Chrome

## Firefox: Cookies.SQLite

it handles Firefox Cookies as Chrome but with a different query, also firefox cookies are not encrypted or if it is it will decrypt them remotely in C2 so it extracts them and sends them immediately to C2

![stealc](/assets/images/14/1-ZC-gSfxqhDdEcbUijRMQRA.png)

SELECT host, isHttpOnly, path, isSecure,expiry, name, value FROM moz_cookies

-   `host`: The domain name of the website that set the cookie.
-   `isHttpOnly`: A boolean value indicating whether the cookie can only be accessed by HTTP requests, or if it can also be accessed by JavaScript.
-   `path`: The path on the website where the cookie is valid.
-   `isSecure`: A boolean value indicating whether the cookie is only sent over secure HTTPS connections.
-   `expiry`: The date and time when the cookie expires.
-   `name`: The name of the cookie.
-   `value`: The value of the cookie.

## Firefox: Places.SQLite

as I have said before places file stores history and some settings like bookmarks etc..

but it only retrieves the history record

![stealc](/assets/images/14/1-GXN-k-AlvTPYXZZbq87hfA.png)
```SQL
SELECT url FROM moz_places LIMIT 1000
```
and here is how this Data was constructed and sent to C2

![stealc](/assets/images/14/1-Koeu1PbLCVTuxQXiCN0A8Q.png)

## Firefox: FormHistory.SQLite

As I said before this file contains data related to automated filling and web forms

![stealc](/assets/images/14/1-53MBaGdLFzvgjy-BE3c6Vg.png)
```sql
SELECT fieldname, value FROM moz_formhistory
```
and here is the result of the query on a Sqlite viewer

![stealc](/assets/images/14/1-zf86IyBKtV2tS72q9-5aTw.png)

_note* this a fake account_ :)

## Firefox: Logins.Json

this file stores the most important data in Firefox so Stealc handles it differently, let’s explain it in formatted steps to make it easier to understand.

1- it gets a handle with the (OPEN_EXISTING) flag for the JSON file not the original file but the file that was copied to  
Program Data path as it did with Chrome

![](https://miro.medium.com/v2/resize:fit:559/1*JgZrFZlqbmJ8RaELm9l8CA.png)

2- it reads the file in memory, let’s parse the file on an online JSON beautifier

![stealc](/assets/images/14/1-zKhLyn5NLJkaaDHn2B-m9A.png)

3- it will get a ptr to 2 elements on this file which are the most important  **“encryptedUserName”**  and  **“encryptedPassword”** using  **strstr API**

![](https://miro.medium.com/v2/resize:fit:624/1*ETihJNlk3FYkzToKL-H39g.png)

4- after getting these two elements it will go forward to encrypt them via some steps but after decoding them from base646 cipher.

![stealc](/assets/images/14/1-cM6Xh1C5x0wcYT8oA7m77A.png)

5- it will execute a call to  **PK11_GetInternalKeySlot t**hat returns a pointer to the internal key slot.

![](https://miro.medium.com/v2/resize:fit:676/1*4yWTzcZl7jYE3KGe-1CzGA.png)

and this is the type of keys

-   `keyType`: The type of key to return the internal key slot for. The key type can be any of the following:
-   **PK11_TYPE_DSA**: A DSA key.
-   **PK11_TYPE_RSA**: An RSA key.
-   **PK11_TYPE_ECDSA**: An ECDSA key.
-   **PK11_TYPE_DH**: A Diffie-Hellman key.
-   **PK11_TYPE_KEA**: A Kerberos key.

6- It then will call  **PK11_Authenticate**,`PK11_Authenticate`  a function typically used to perform authentication or login actions in the context of cryptographic tokens, security modules, or hardware security modules (HSMs). Here's a general description of what this function does

![stealc](/assets/images/14/1-AvEqFNr-DfK3Rnu9Jl-nvA.png)

7- then it will call  **PK11SDR_Decrypt** to decrypt the cipher text using the token offered before from the Authenticate function.

![](https://miro.medium.com/v2/resize:fit:793/1*ABbZpx-96ZufxpWdZ4vfKQ.png)

# **Send Login Data**

after allocating all usernames and passwords Stealch will format this data and send it to C2, and in my VM I only had installed Chrome and logged into only one website due to testing purposes (**dropbox.com**).

it first will encode the allocated login data which is formatted in YAML format.
```
browser: Google Chrome  
profile: Default  
url: https://www.dropbox.com/login  
login: f73eb0a00c@emailboxa.online  
password: 123456#Lol
```
![stealc](/assets/images/14/1-vmyrUbQAogyYDLWFAq9iTw.png)

then it will encode the string “docia.docx” which will be used as an identifier for the login data

![stealc](/assets/images/14/1-4qFONd2Rfd2tF7wYUjRSAw.png)

![stealc](/assets/images/14/1-tKGaQX-BTqEx6rNgMoBaSw.png)

# Local Crypto Currency Wallets

the next part involves how Stealc Exfiltrate crypto wallets which data is stored on the device through some steps.

1- it first asks C2 for Wallets configuration.

![stealc](/assets/images/14/1-rn6r-5DQwV6-_rvtv4zUUQ.png)

![stealc](/assets/images/14/1-qf-iwaatEzfsQWQCZ0BIxg.png)

and here is the decoded data

crypto wallet Name | wallet configuration path | boolean value  
       
      
```       
Bitcoin Core    		|\Bitcoin\wallets\|wallet.dat|1|  
Bitcoin Core Old		|\Bitcoin\|*wallet*.dat|0|  
Dogecoin				|\Dogecoin\|*wallet*.dat|0|  
Raven Core				|\Raven\|*wallet*.dat|0|  
Daedalus Mainnet		|\Daedalus Mainnet\wallets\|she*.sqlite|0|  
Blockstream Green		|\Blockstream\Green\wallets\|*.*|1|  
Wasabi Wallet			|\WalletWasabi\Client\Wallets\|*.json|0|  
Ethereum				|\Ethereum\|keystore|0|  
Electrum				|\Electrum\wallets\|*.*|0|  
ElectrumLTC				|\Electrum-LTC\wallets\|*.*|0|  
Exodus					|\Exodus\|exodus.conf.json|0|  
Exodus					|\Exodus\|window-state.json|0|  
Exodus					|\Exodus\exodus.wallet\|passphrase.json|0|  
Exodus					|\Exodus\exodus.wallet\|seed.seco|0|  
Exodus					|\Exodus\exodus.wallet\|info.seco|0|  
Electron Cash			|\ElectronCash\wallets\|*.*|0|  
MultiDoge				|\MultiDoge\|multidoge.wallet|0|  
Jaxx Desktop (old)		|\jaxx\Local Storage\|file__0.localstorage|0|  
Jaxx Desktop			|\com.liberty.jaxx\IndexedDB\file__0.indexeddb.leveldb\|*.*|0|  
Atomic					|\atomic\Local Storage\leveldb\|*.*|0|  
Binance					|\Binance\|app-store.json|0|  
Binance					|\Binance\|simple-storage.json|0|  
Binance					|\Binance\|.finger-print.fp|0|  
Coinomi					|\Coinomi\Coinomi\wallets\|*.wallet|1|  
Coinomi					|\Coinomi\Coinomi\wallets\|*.config|1|
```
then the data is parsed on the stack by creating an array of structures for each wallet.
```c
struct wallet  
{  
  DWORD* Wallet_Name;  
  DWORD Null_Value;  
  DWORD Wallet_Name_Length;  
  DWORD* Wallet_Path;  
  DWORD Null_Value_1;  
  DWORD Wallet_Path_Length;  
  DWORD* Wallet_Config_File;  
  DWORD Null_Value_2;  
  DWORD Wallet_Config_File_Length;  
  bool flg_value; // 0 or 1  
    
};
```
![stealc](/assets/images/14/1-caw7XsRfOievCvF6uv1owQ.png)

inside `sub_40111E` it will start stealth behavior related to wallets by getting the path of (`APPDATA\Romaing`) using  **SHGetFolderPathA**  API using `0x1A` as CSIDL

![](https://miro.medium.com/v2/resize:fit:756/1*bJrUHNL7gQTjnfs2ssjk1Q.png)

inside (%APPDATA%Romaing) it will iterate over all files until it hits the wallet path that passed previously to `sub_40111E` which for the first element in the wallets array is (`Bitcoin\wallets`), so I have created this file to emulate that.

![stealc](/assets/images/14/1-VlQuCG6jOcWBxrlAFCQkPg.png)

so it will keep iterating on files in this folder `"APPDATA\Romaing\\"` until it finds the `"Bitcoin\wallets"` folder then it searches for “wallet.dat” which stores the wallet information

![stealc](/assets/images/14/1-T5ttdxfji9pTX5Mj0JNOEg.png)

then it will copy this file “wallet.dat” to %ProgramData” folder with a randomly generated name.

then it will read the created file

![stealc](/assets/images/14/1-KCBGQWQS_ahWZSHrQYlXvQ.png)

![stealc](/assets/images/14/1-LnnbMlf_Vz75-a3yDox3gA.png)

then this file content is base64 encoded and sent to C2.

## Efiltrate Files

then C2 will feed Stealc with some file names to collect and exfiltrate it to TA, these files are related to some cryptocurrency wallet configuration and local password file where the user may save its passwords.

![stealc](/assets/images/14/1-kp1vufIAC-ows10Pc4zZcA.png)

![stealc](/assets/images/14/1-un3lcI6_C1Mqnv7Iv764yg.png)
```
|%DESKTOP%\|*seed*.*,*passphrase*.*,*erc20*.*,*trc20*.*,*exodus*.*,*metamask*.*,*binance*.*,*wallet*.*|0|1|0|  
|%DOCUMENTS%\|*seed*.*,*passphrase*.*,*erc20*.*,*trc20*.*,*exodus*.*,*metamask*.*,*binance*.*,*wallet*.*|0|1|0|
```
then it will try to get the path of some common file and check if the path exists on the decoded stream received from C2

```python
_Desktop_

_APPDATA\Romaing_

_APPDATA\Local_
 
_<UserProfile>_
 
_Document_
 
_ProgramFiles_
 
_ProgramFiles x86_
 
_Recent_
```

and then will iterate over these folders and subfolders, if it finds any file that contains any string of those which was sent from C2 like “seed”, “passphrase”,” MetaMask” etc.., it will read its content and send it to C2

## Usage of COM

COM => Stealc is using the component object model to handle ShellLinks or shortcuts cause it may find a file that has a name like “seedX.lnk” so if it copies this file it will copy the shortcut itself not the original file pointed by the shortcut so it handle this via COM to get the original file, so lets summary this in some steps.

![](https://miro.medium.com/v2/resize:fit:378/1*Hj3taJFNh9l5mFe9QDgcHA.png)

1: it initializes the com interface via  **CoCreateInstance**
```c
HRESULT CoCreateInstance(  
  [in]  REFCLSID  rclsid,  
  [in]  LPUNKNOWN pUnkOuter,  
  [in]  DWORD     dwClsContext,  
  [in]  REFIID    riid,  
  [out] LPVOID    *ppv  
);
```
the  **_rclsid_** used here is  **{000214EE-0000–0000-C000–000000000046} => IShellLinkA** so to handle this interface we need to convert the type of **_PPV_** to be a type of **_(_IShellLinkA*)**  which will contain a handle to the created  **_COM_**

![stealc](/assets/images/14/1-EcPqlv1MbfYg02kjkaKoCw.png)

2- it will create another object for another interface by this time using the previously created COM and execute a call for
```
IShellLinkA->lpVtbl->QueryInterface()
```
**{0000010b-0000–0000-C000–000000000046} =>** [**UCOMIPersistFile**](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.ucomipersistfile?view=netframework-4.8.1)
```
unk_40f040 => refers to interface-id
```
![stealc](/assets/images/14/1-2Vxzg5q65VbC5XIwYtpWww.png)

the object refers to IPersistFile Interface.

3-then it will get a handle to the file using  [**_load_**](https://learn.microsoft.com/en-us/windows/win32/api/objidl/nf-objidl-ipersistfile-load) method from  **_IPersistFile_** interface with Read permission (STGM_READ) => second argument

![stealc](/assets/images/14/1-wiReI7p0p75P_rwwwTrTlw.png)

4- it executes a call to  [**_resolve_**](https://learn.microsoft.com/en-us/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinka-resolve) method to find the target of a Shell link, even if it has been moved or renamed, (SLR_NO_UI) to not display a dialog box if the link cannot be resolved

![stealc](/assets/images/14/1-F2RFGnI6djS6jNkCZOZdbg.png)

5- next, it will get the path of the file pointed by the short link using  [**_GetPath_**](https://learn.microsoft.com/en-us/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinka-getpath) method with (**SLGP_RAWPATH**) to retrieve the raw path name

```c
HRESULT GetPath(
  [out]     LPSTR            pszFile,  
  [in]      int              cch,  
  [in, out] WIN32_FIND_DATAA *pfd,  
  [in]      DWORD            fFlags);
```

![stealc](/assets/images/14/1-J6k6_65KHARVvuCzaCfVkQ.png)

*file path I mean*

then it will copy this file to program data and copy its content into memory using Readfile API and is sent to C2.

## Steal Steam Files

Steal can collect Steam credentials and post them to C2, for Gamers A Steam account is the most valuable resource on the machine, so how does it handle this

1- it gets the path of the Steam folder using the Registry, Steam path is saved on

`**_HKEY_CURRENT_USER\Software\Valve\Steam_**`

and it retrieves the path using  **_RegQueryValueExA_** to get “SteamPath” key value

![stealc](/assets/images/14/1-jCqXRYCdf79MyAU8dQFg5w.png)

2- After getting the Steam path it will try to get a handle on some important files used by steam

![stealc](/assets/images/14/1-XQPcqFgnPizApMUcD5odQg.png)

`ssfn`  files are part of the Steam Guard process, a security feature provided by the Steam gaming platform, The Steam servers use the computer identifier to verify that the user is logging in from an authorized computer

`config.vdf`  is used to store various configuration settings for the Steam client, including user preferences, interface settings, and other configurations.

`loginusers.vdf`  file that typically contains information related to user accounts that have logged in to Steam on a particular computer. This includes data about the user's Steam account, including the username, Steam ID, and other relevant account information.

`DialogConfig.vdf`  contains configurations related to various dialog boxes and user interface (UI) elements within the Steam client. These dialog boxes may include settings, options, and preferences related to how Steam interacts with users.

3- For each file, it invokes the function  `sub_40AB8E`. Within this function, a handle to the file is obtained, followed by reading its contents. Subsequently, the function appends the Data Identifier that will be utilized in the C2 (Command and Control) connection

the identifier, in this case, is “softsteam\” followed by the file name

![stealc](/assets/images/14/1-_JPZ1SEZbpTDAfWC2e-z2Q.png)

## Steal Discord Tokens

Stealing Discord Databases is not that easy, It costs more effort so how ?;

1-resolve the path where Discord Saves its files and configuration and then check the if current file exists on Leveldb folder

![stealc](/assets/images/14/1-FdTHSyNTLq5gR8Sw_uXt2A.png)

```js
_%APPDATA%\Romaing\discord\Local Storage\leveldb\CURRENT_
%APPDATA%\Romaing\discord\Local Storage\leveldb\\
```

2- It invokes  **_sub_40B110E_** with the path of Leveldb folder as an argument

![stealc](/assets/images/14/1-7XvXJhJXdPCIrK4QkNGVFA.png)

3- inside sub_40B110E it will pass each file in leveldb folder to sub_40AEE5, these files are database files

![stealc](/assets/images/14/1-whZYVDpBbZ8rR5C5H8TVSg.png)

4-Within the context of  `sub_40AEE5`, the most pivotal actions revolve around the decryption of a crucial token. This decryption process shares similarities with how Chrome handles sensitive data in its files, as discussed previously. Let's provide a concise overview of how this decryption typically unfolds

4.1- it gets the path of the LocalState file which contains the AES key

![stealc](/assets/images/14/1-Fk7xbmhHKZHF13z-MUxpzQ.png)

4.2 it will read LocalState File which contains the Encrypted Key,

the key is base64 encoded and encrypted with DPAPI

![stealc](/assets/images/14/1-uv038YQKI0VJOES9A6OokA.png)

then it will decrypt it using DPAPI

![stealc](/assets/images/14/1-K6haUNFAc0SrA0qB5c20Qg.png)

![stealc](/assets/images/14/1-CofjnMVIPwRYfYtFoGaqEQ.png)

using  **_CryptUnProtectData_** will get the AES key which will be used later to Generate the AES key

![stealc](/assets/images/14/1-MmTyv8ED4W9x2T9i1-h7yg.png)

**4.3**  After getting the handle it manipulates the DB file to search for the token, it first reads the DB file and then searches for “**dQw4w9WgXcQ**” which is the start or ID of Discord Tokens.

![stealc](/assets/images/14/1-XyotRKLV9jLASe5NuwNbsA.png)

the value assigned with this token identifier is base64 encoded

![stealc](/assets/images/14/1-3KBlr6pYhILaH446E4GujA.png)

4.4 then the data is AES decrypted using the Key handle optioned before

5- the last part of Stealing Discord Tokens is adding a Data Identifier to the allocated data and this time is  `**“soft\Discord\tokens.txt”**`

![stealc](/assets/images/14/1-cVg9XBaH3zhi9U178rqJQg.png)

## Steal Telegram Sessions

it will get the path of telegram files and DBs which is located at  `_“%APPDATA%\Romaing` and try to locate some files which is used to to store telegram sessions like_

`**%APPDATA%\Romaing\key_datas\D877F783D5D3EF8C\map**`

the map file contains the current telegram session, so it reads it and sends it directly to C2.

![stealc](/assets/images/14/1-KvXotMimX0vQ4v2WgEt6Ow.png)

The Data Identifier here is  `**_“soft\Telegram\maps”_**`

the source code of this task =>  [**_click here_**](https://github.com/p3pperp0tts/malware_decompiled_code/blob/master/GrandSteal/GrandSteal.Client.Data/GrandSteal.Client.Data/Recovery/TelegramManager.cs)

## Steal qTox Files

qTox provides an easy-to-use application that allows you to connect with friends and family without anyone else listening in, so it’s like Telegram :)

Stealc collects “*.ini” files which are located at

`**_Appdata\romaing\tox\*.ini_**`

and then send it To C2

![stealc](/assets/images/14/1-TilCkOThc1nZdhK1KvVvyg.png)

## Steal OutLook Credentials

In its covert operation, Stealc demonstrates its decryption prowess by unraveling the registry key where Outlook securely stores its configuration and account data. This intricate process involves the meticulous iteration over a total of 24 registry keys to successfully extract valuable Outlook account information, including usernames and passwords.
```
Software\Microsoft\Windows NT\CurrentVersion\Windows Messaging Subsystem\Profiles\Outlook\9375CFF0413111d3B88A00104B2A6676\  
Software\Microsoft\Office\13.0\Outlook\Profiles\Outlook\9375CFF0413111d3B88A00104B2A6676\  
Software\Microsoft\Office\14.0\Outlook\Profiles\Outlook\9375CFF0413111d3B88A00104B2A6676\  
Software\Microsoft\Office\15.0\Outlook\Profiles\Outlook\9375CFF0413111d3B88A00104B2A6676\  
Software\Microsoft\Office\16.0\Outlook\Profiles\Outlook\9375CFF0413111d3B88A00104B2A6676\  
Software\Microsoft\WindowsMessaging Subsystem\Profiles\9375CFF0413111d3B88A00104B2A667
```
, and for each Key, it tries to open these 4 sub-keys
```
00000001  
00000002  
00000003  
00000004
```
![](https://miro.medium.com/v2/resize:fit:828/1*MC3FoYtJKastI3iLhNcR6g.png)

so for each subkey, it calls sub_40B8D2, this function involves getting the subkey

![stealc](/assets/images/14/1-Ed_StqqEwGg-Uld_FO3lig.png)

for each key, it gets the name and if it matches “**password**” it gets the key value

![](https://miro.medium.com/v2/resize:fit:701/1*a81ArsGXt255sEb1Aq4eSg.png)

using  **_CryptUnprotectData_**, it will decrypt the password value and convert it to a MultiByte string

![stealc](/assets/images/14/1-evoCRABMttPvJWBNKSeYjg.png)

so as I said 24 times this function is called searching for accounts and their passwords, then it adds `“soft\Outlook\accounts.txt”` as an Identifier for the transferred data.

## Steal Pidgin Credentials

Pidgin is an open-source instant messaging (IM) client that allows users to communicate with friends and colleagues through various IM networks

so Stealc tries to search for its config and DB files and send it To C2, it resolves the path where  **Pidgin** config is located

`**_%APPDATA%\Romaing\purple\accounts.xml_**`

![stealc](/assets/images/14/1-l2py1HeCDmKZP7r_G0oSww.png)

## Act as Downloader

the last stealth behavior is that Stealc asks C2 for another stage to execute it and then drops the file in the Temp directory then executes it.

![stealc](/assets/images/14/1-alygFeiDT_rvGCSIYJDCsg.png)

## Removing it Self

the last malware behavior is that Stealc deletes the downloaded Dlls, removes itself from the machine, and exits the process.

![stealc](/assets/images/14/1-8znayxgQSEH9pGylFPPzfw.png)

```powershell
"C:\Windows\system32\cmd.exe" /c timeout /t 5 & del /f /q "<Current File Path>" & del "C:\ProgramData\*.dll" & exit
```

so my analysis ends here I hope this article meets your expectations and if u want to correct anything don't hesitate to DM me

## IOCs
```json
sha256 : 1E09D04C793205661D88D6993CB3E0EF5E5A37A8660F504C1D36B0D8562E63A2  
         77d6f1914af6caf909fa2a246fcec05f500f79dd56e5d0d466d55924695c702d  
         87f18bd70353e44aa74d3c2fda27a2ae5dd6e7d238c3d875f6240283bc909ba6  
  
C2 : hxxp://fff-ttt[.]com/984dd96064cb23d7.php  
   : hxxp://moneylandry[.]com/2ccaf544c0cf7de7  
   : hxxp://162.0.238[.]10/752e382b4dcf5e3f.php  
   : hxxp://185.5.248[.]95/api.php  
   : hxxp://aa-cj[.]com/6842f013779f3d08.php  
   : hxxp://moneylandry[.]com/bef7fb05c9ef6540.php  
   : hxxp://94.142.138[.]48/f9f76ae4bb7811d9.php  
   : hxxp://185.247.184[.]7/8c3498a763cc5e26.php  
   : hxxps://185.247.184[.]7/8c3498a763cc5e26.php  
   : hxxp://23.88.116[.]117/api.php  
   : hxxp://95.216.112[.]83/413a030d85acf448.php  
   : hxxp://179.43.162[.]2/d8ab11e9f7bc9c13.php  
   : hxxp://185.5.248[.]95/c1377b94d43eacea.php
```
# Yara Rule
```python
rule Detect_Stealc_Stealer{  
  
    meta:  
        description="Stealc Info Stealer"    
        author="@FarghlyMal"  
        hash="sha256,1E09D04C793205661D88D6993CB3E0EF5E5A37A8660F504C1D36B0D8562E63A2"  
        Date="8/11/2023"     
 strings:  
        $s1="block"  
        $s2="Network Info:"  
        $s3="- IP: IP?"  
        $s4="- Country: ISO?"  
        $hex_value = {74 03 75 01 b8 e8}  
        $hex_value2= {8B 48 F8 83 C0 F0 C7 00 01 00 00 00 85 C9 74 0A 83 39 00}  
      
    condition:  
        uint16(0)==0x5A4D and all of($s*) and all of ($hex_value*)   
   
}
```

We hope this post spreads awareness to the blue teamers of this interesting malware techniques, and adds a weapon to the red teamers arsenal.     

Big thanks to [@farghlymal](https://twitter.com/farghlymal) for this detailed report.    

By Cyber Threat Hunters from MSSPLab:      

- [@farghlymal](https://www.linkedin.com/in/aziz-farghly/)         

### References

[https://malpedia.caad.fkie.fraunhofer.de/details/win.stealc](https://malpedia.caad.fkie.fraunhofer.de/details/win.stealc)   
[https://farghlymal.github.io/Stealc-Stealer-Analysis/](https://farghlymal.github.io/Stealc-Stealer-Analysis/)    
[https://twitter.com/farghlymal](https://twitter.com/farghlymal)     
[Stealc config decryptor](https://github.com/FarghlyMal/Decryptors-and-Extractors/tree/main/Stealc%20Stealer)    
[Malware Analysis Stealc - part 1](/threat-hunting/2023/11/09/malware-analysis-stealc-1.html)

Thanks for your time happy hacking and good bye!         
*All drawings and screenshots are from farghlymal blog*       
